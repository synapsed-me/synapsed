//! Snapshot tests for code generation
//! 
//! These tests ensure that generated code remains consistent across changes.
//! Use `cargo insta review` to update snapshots when intentional changes are made.

use synapsed_builder::prelude::*;
use synapsed_builder::{
    builder::{SynapsedBuilder, StorageBackend, ObservabilityLevel, NetworkType},
    templates::Templates,
    recipe::{Recipe, RecipeManager},
};
use std::collections::HashMap;
use serde_json::json;
use insta::{assert_yaml_snapshot, assert_snapshot};

// Helper to create consistent test applications
fn create_standard_app() -> Application {
    SynapsedBuilder::new("test-app")
        .description("Standard test application for snapshots")
        .add_intent_verification()
        .add_storage(StorageBackend::Sqlite)
        .add_observability(ObservabilityLevel::Standard)
        .env("RUST_LOG", "info")
        .env("DATABASE_URL", "sqlite://test.db")
        .configure("synapsed-intent", json!({
            "max_depth": 5,
            "timeout_ms": 30000
        }))
        .configure("synapsed-storage", json!({
            "pool_size": 10,
            "connection_timeout": 5
        }))
        .build()
        .unwrap()
}

fn create_complex_app() -> Application {
    SynapsedBuilder::new("complex-app")
        .description("Complex application with many components")
        .add_intent_verification()
        .add_consensus()
        .add_storage(StorageBackend::Postgres)
        .add_observability(ObservabilityLevel::Full)
        .add_network(NetworkType::P2P)
        .add_payments()
        .connect(
            "synapsed-payments", "transaction_created",
            "synapsed-consensus", "propose"
        )
        .connect(
            "synapsed-consensus", "committed",
            "synapsed-storage", "persist"
        )
        .connect(
            "synapsed-storage", "persisted",
            "synapsed-substrates", "emit_event"
        )
        .env("RUST_LOG", "debug")
        .env("NODE_ENV", "production")
        .env("P2P_PORT", "4001")
        .configure("synapsed-consensus", json!({
            "consensus_type": "hotstuff",
            "committee_size": 5,
            "block_time_ms": 1000
        }))
        .configure("synapsed-payments", json!({
            "supported_currencies": ["USD", "EUR", "BTC"],
            "max_transaction_amount": 100000,
            "risk_assessment_enabled": true
        }))
        .build()
        .unwrap()
}

#[test]
fn test_snapshot_simple_cargo_toml() {
    let app = create_standard_app();
    let cargo_toml = app.generate_cargo_toml();
    
    assert_snapshot!(cargo_toml, @r###"
    [package]
    name = "test-app"
    version = "0.1.0"
    edition = "2021"
    description = "Standard test application for snapshots"

    [dependencies]
    synapsed-core = { version = "*" }
    synapsed-intent = { version = "*" }
    synapsed-verify = { version = "*" }
    synapsed-storage = { version = "*" }
    synapsed-substrates = { version = "*" }
    tokio = { version = "1", features = ["full"] }
    anyhow = "1.0"
    serde = { version = "1.0", features = ["derive"] }
    serde_json = "1.0"
    tracing = "0.1"
    tracing-subscriber = { version = "0.3", features = ["env-filter"] }

    [[bin]]
    name = "test-app"
    path = "src/main.rs"
    "###);
}

#[test]
fn test_snapshot_complex_cargo_toml() {
    let app = create_complex_app();
    let cargo_toml = app.generate_cargo_toml();
    
    assert_snapshot!(cargo_toml, @r###"
    [package]
    name = "complex-app"
    version = "0.1.0"
    edition = "2021"
    description = "Complex application with many components"

    [dependencies]
    synapsed-core = { version = "*" }
    synapsed-intent = { version = "*" }
    synapsed-verify = { version = "*" }
    synapsed-consensus = { version = "*" }
    synapsed-net = { version = "*" }
    synapsed-storage = { version = "*" }
    synapsed-substrates = { version = "*" }
    synapsed-monitor = { version = "*" }
    synapsed-payments = { version = "*" }
    synapsed-identity = { version = "*" }
    synapsed-crypto = { version = "*" }
    tokio = { version = "1", features = ["full"] }
    anyhow = "1.0"
    serde = { version = "1.0", features = ["derive"] }
    serde_json = "1.0"
    tracing = "0.1"
    tracing-subscriber = { version = "0.3", features = ["env-filter"] }

    [[bin]]
    name = "complex-app"
    path = "src/main.rs"
    "###);
}

#[test]
fn test_snapshot_simple_main_rs() {
    let app = create_standard_app();
    let main_rs = app.generate_main_rs();
    
    assert_snapshot!(main_rs, @r###"
    //! test-app - Standard test application for snapshots
    //! 
    //! Generated by Synapsed Builder

    use anyhow::Result;
    use synapsed_core::prelude::*;
    use synapsed_intent::prelude::*;
    use synapsed_verify::prelude::*;
    use synapsed_storage::prelude::*;
    use synapsed_substrates::prelude::*;
    use tracing::{info, error};
    use tracing_subscriber::{EnvFilter, fmt};

    #[tokio::main]
    async fn main() -> Result<()> {
        // Initialize tracing
        fmt()
            .with_env_filter(EnvFilter::from_default_env())
            .init();
        
        info!("Starting test-app...");
        
        // Initialize components
        info!("Initializing synapsed-core...");
        let synapsed_core = synapsed_core::initialize().await?;
        
        info!("Initializing synapsed-intent...");
        let synapsed_intent = synapsed_intent::initialize().await?;
        
        info!("Initializing synapsed-verify...");
        let synapsed_verify = synapsed_verify::initialize().await?;
        
        info!("Initializing synapsed-storage...");
        let synapsed_storage = synapsed_storage::initialize().await?;
        
        info!("Initializing synapsed-substrates...");
        let synapsed_substrates = synapsed_substrates::initialize().await?;
        
        // Apply configurations
        synapsed_intent.configure(serde_json::json!({
            "max_depth": 5,
            "timeout_ms": 30000
        })).await?;
        
        synapsed_storage.configure(serde_json::json!({
            "pool_size": 10,
            "connection_timeout": 5
        })).await?;
        
        // Setup connections
        // No connections configured
        
        info!("test-app is running!");
        
        // Wait for shutdown signal
        tokio::signal::ctrl_c().await?;
        
        info!("Shutting down test-app...");
        Ok(())
    }
    "###);
}

#[test]
fn test_snapshot_complex_main_rs() {
    let app = create_complex_app();
    let main_rs = app.generate_main_rs();
    
    // For complex main.rs, just verify key sections exist
    assert!(main_rs.contains("use synapsed_consensus::prelude::*;"));
    assert!(main_rs.contains("use synapsed_payments::prelude::*;"));
    assert!(main_rs.contains("synapsed_payments.connect"));
    assert!(main_rs.contains("synapsed_consensus.connect"));
    assert!(main_rs.contains("\"consensus_type\": \"hotstuff\""));
}

#[test]
fn test_snapshot_env_file() {
    let app = create_complex_app();
    let env_content = app.generate_env_file();
    
    assert_snapshot!(env_content, @r###"
    # Environment variables for complex-app
    # Generated by Synapsed Builder

    RUST_LOG=debug
    NODE_ENV=production
    P2P_PORT=4001
    "###);
}

#[test]
fn test_snapshot_config_json() {
    let app = create_standard_app();
    let config = app.generate_config_json();
    
    // Parse and re-serialize for consistent formatting
    let parsed: serde_json::Value = serde_json::from_str(&config).unwrap();
    let formatted = serde_json::to_string_pretty(&parsed).unwrap();
    
    assert_snapshot!(formatted, @r###"
    {
      "name": "test-app",
      "description": "Standard test application for snapshots",
      "components": {
        "synapsed-intent": {
          "max_depth": 5,
          "timeout_ms": 30000
        },
        "synapsed-storage": {
          "connection_timeout": 5,
          "pool_size": 10
        }
      }
    }
    "###);
}

#[test]
fn test_snapshot_template_verified_ai_agent() {
    let app = Templates::verified_ai_agent()
        .configure("synapsed-storage", json!({
            "path": "./agent.db"
        }))
        .build()
        .unwrap();
    
    let cargo_toml = app.generate_cargo_toml();
    
    // Verify key components are present
    assert!(cargo_toml.contains("synapsed-intent"));
    assert!(cargo_toml.contains("synapsed-verify"));
    assert!(cargo_toml.contains("synapsed-substrates"));
    assert!(cargo_toml.contains("verified-ai-agent"));
}

#[test]
fn test_snapshot_template_payment_system() {
    let app = Templates::secure_payment_system()
        .configure("synapsed-payments", json!({
            "currencies": ["USD", "EUR"]
        }))
        .build()
        .unwrap();
    
    let main_rs = app.generate_main_rs();
    
    // Verify payment-specific components
    assert!(main_rs.contains("synapsed_payments"));
    assert!(main_rs.contains("synapsed_consensus"));
    assert!(main_rs.contains("synapsed_crypto"));
}

#[test]
fn test_snapshot_recipe_yaml() {
    let recipe = Recipe {
        name: "test-recipe".to_string(),
        description: "Test recipe for snapshots".to_string(),
        version: "1.0.0".to_string(),
        components: vec![
            "synapsed-core".to_string(),
            "synapsed-intent".to_string(),
            "synapsed-verify".to_string(),
        ],
        connections: vec![
            Connection {
                from: "synapsed-intent".to_string(),
                event: "intent_declared".to_string(),
                to: "synapsed-verify".to_string(),
                handler: "verify_intent".to_string(),
            }
        ],
        config: {
            let mut config = HashMap::new();
            config.insert(
                "synapsed-intent".to_string(),
                json!({
                    "max_depth": 3,
                    "timeout_ms": 10000
                })
            );
            config
        },
    };
    
    assert_yaml_snapshot!(recipe);
}

#[test]
fn test_snapshot_dockerfile() {
    let app = create_standard_app();
    let dockerfile = app.generate_dockerfile();
    
    assert_snapshot!(dockerfile, @r###"
    # Build stage
    FROM rust:1.75 as builder

    WORKDIR /app
    COPY Cargo.toml Cargo.lock ./
    COPY src ./src

    RUN cargo build --release

    # Runtime stage
    FROM debian:bookworm-slim

    RUN apt-get update && apt-get install -y \
        ca-certificates \
        && rm -rf /var/lib/apt/lists/*

    WORKDIR /app

    COPY --from=builder /app/target/release/test-app /app/test-app
    COPY config.json .env ./

    ENV RUST_LOG=info

    EXPOSE 8080

    CMD ["./test-app"]
    "###);
}

#[test]
fn test_snapshot_docker_compose() {
    let app = create_complex_app();
    let docker_compose = app.generate_docker_compose();
    
    assert_snapshot!(docker_compose, @r###"
    version: '3.8'

    services:
      complex-app:
        build: .
        container_name: complex-app
        environment:
          - RUST_LOG=debug
          - NODE_ENV=production
          - P2P_PORT=4001
        ports:
          - "8080:8080"
          - "4001:4001"
        volumes:
          - ./data:/app/data
          - ./config.json:/app/config.json:ro
        networks:
          - synapsed-network
        restart: unless-stopped

      postgres:
        image: postgres:15
        environment:
          POSTGRES_DB: synapsed
          POSTGRES_USER: synapsed
          POSTGRES_PASSWORD: synapsed
        volumes:
          - postgres-data:/var/lib/postgresql/data
        networks:
          - synapsed-network

    networks:
      synapsed-network:
        driver: bridge

    volumes:
      postgres-data:
    "###);
}

#[test]
fn test_snapshot_makefile() {
    let app = create_standard_app();
    let makefile = app.generate_makefile();
    
    assert_snapshot!(makefile, @r###"
    # Makefile for test-app
    # Generated by Synapsed Builder

    .PHONY: build run test clean docker-build docker-run

    # Build the application
    build:
    	cargo build --release

    # Run the application
    run:
    	cargo run --release

    # Run tests
    test:
    	cargo test --all-features

    # Clean build artifacts
    clean:
    	cargo clean
    	rm -rf target/

    # Build Docker image
    docker-build:
    	docker build -t test-app:latest .

    # Run with Docker
    docker-run:
    	docker run -it --rm \
    		-p 8080:8080 \
    		-v $(PWD)/data:/app/data \
    		test-app:latest

    # Development mode with hot reload
    dev:
    	cargo watch -x run

    # Format code
    fmt:
    	cargo fmt --all

    # Lint code
    lint:
    	cargo clippy --all-targets --all-features -- -D warnings

    # Generate documentation
    docs:
    	cargo doc --all-features --open
    "###);
}

#[test]
fn test_snapshot_readme() {
    let app = create_standard_app();
    let readme = app.generate_readme();
    
    // Verify key sections exist
    assert!(readme.contains("# test-app"));
    assert!(readme.contains("## Overview"));
    assert!(readme.contains("## Components"));
    assert!(readme.contains("## Configuration"));
    assert!(readme.contains("## Running"));
    assert!(readme.contains("Generated by Synapsed Builder"));
}

#[test]
fn test_snapshot_github_workflow() {
    let app = create_standard_app();
    let workflow = app.generate_github_workflow();
    
    assert_snapshot!(workflow, @r###"
    name: CI

    on:
      push:
        branches: [ main ]
      pull_request:
        branches: [ main ]

    env:
      CARGO_TERM_COLOR: always

    jobs:
      test:
        runs-on: ubuntu-latest
        steps:
        - uses: actions/checkout@v3
        
        - name: Install Rust
          uses: actions-rs/toolchain@v1
          with:
            toolchain: stable
            override: true
            components: rustfmt, clippy
        
        - name: Cache cargo
          uses: actions/cache@v3
          with:
            path: |
              ~/.cargo/registry
              ~/.cargo/git
              target
            key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
        
        - name: Check formatting
          run: cargo fmt -- --check
        
        - name: Run clippy
          run: cargo clippy --all-targets --all-features -- -D warnings
        
        - name: Run tests
          run: cargo test --all-features
        
        - name: Build release
          run: cargo build --release

      docker:
        runs-on: ubuntu-latest
        needs: test
        if: github.ref == 'refs/heads/main'
        steps:
        - uses: actions/checkout@v3
        
        - name: Build Docker image
          run: docker build -t test-app:latest .
    "###);
}

// Test that snapshots remain consistent across different builder methods
#[test]
fn test_snapshot_consistency_between_methods() {
    // Build same app using different methods
    let app1 = SynapsedBuilder::new("consistency-test")
        .add_intent_verification()
        .add_storage(StorageBackend::Sqlite)
        .build()
        .unwrap();
    
    let app2 = SynapsedBuilder::new("consistency-test")
        .add_component("synapsed-intent")
        .add_component("synapsed-verify")
        .add_component("synapsed-storage")
        .build()
        .unwrap();
    
    // Components should be the same (after sorting)
    let mut comps1 = app1.components.clone();
    let mut comps2 = app2.components.clone();
    comps1.sort();
    comps2.sort();
    
    assert_eq!(comps1, comps2, "Different builder methods should produce same components");
}

// Test that generated code compiles (would need actual compilation test)
#[test]
fn test_generated_code_validity() {
    let app = create_complex_app();
    
    // Verify Cargo.toml has required fields
    let cargo_toml = app.generate_cargo_toml();
    assert!(cargo_toml.contains("[package]"));
    assert!(cargo_toml.contains("name ="));
    assert!(cargo_toml.contains("version ="));
    assert!(cargo_toml.contains("[dependencies]"));
    
    // Verify main.rs has required structure
    let main_rs = app.generate_main_rs();
    assert!(main_rs.contains("#[tokio::main]"));
    assert!(main_rs.contains("async fn main()"));
    assert!(main_rs.contains("Result<()>"));
    assert!(main_rs.contains("use"));
    
    // Verify config.json is valid JSON
    let config = app.generate_config_json();
    serde_json::from_str::<serde_json::Value>(&config)
        .expect("Generated config.json should be valid JSON");
}

// Extension trait for Application to generate additional files
impl Application {
    fn generate_env_file(&self) -> String {
        let mut content = String::from("# Environment variables for ");
        content.push_str(&self.name);
        content.push_str("\n# Generated by Synapsed Builder\n\n");
        
        for (key, value) in &self.env {
            content.push_str(&format!("{}={}\n", key, value));
        }
        
        content
    }
    
    fn generate_config_json(&self) -> String {
        let config = json!({
            "name": self.name,
            "description": self.description,
            "components": self.config,
        });
        
        serde_json::to_string_pretty(&config).unwrap()
    }
    
    fn generate_dockerfile(&self) -> String {
        format!(r#"# Build stage
FROM rust:1.75 as builder

WORKDIR /app
COPY Cargo.toml Cargo.lock ./
COPY src ./src

RUN cargo build --release

# Runtime stage
FROM debian:bookworm-slim

RUN apt-get update && apt-get install -y \
    ca-certificates \
    && rm -rf /var/lib/apt/lists/*

WORKDIR /app

COPY --from=builder /app/target/release/{} /app/{}
COPY config.json .env ./

ENV RUST_LOG=info

EXPOSE 8080

CMD ["./{}"]
"#, self.name, self.name, self.name)
    }
    
    fn generate_docker_compose(&self) -> String {
        let mut compose = format!(r#"version: '3.8'

services:
  {}:
    build: .
    container_name: {}
    environment:"#, self.name, self.name);
        
        for (key, value) in &self.env {
            compose.push_str(&format!("\n      - {}={}", key, value));
        }
        
        compose.push_str(r#"
    ports:
      - "8080:8080"
      - "4001:4001"
    volumes:
      - ./data:/app/data
      - ./config.json:/app/config.json:ro
    networks:
      - synapsed-network
    restart: unless-stopped

  postgres:
    image: postgres:15
    environment:
      POSTGRES_DB: synapsed
      POSTGRES_USER: synapsed
      POSTGRES_PASSWORD: synapsed
    volumes:
      - postgres-data:/var/lib/postgresql/data
    networks:
      - synapsed-network

networks:
  synapsed-network:
    driver: bridge

volumes:
  postgres-data:
"#);
        
        compose
    }
    
    fn generate_makefile(&self) -> String {
        format!(r#"# Makefile for {}
# Generated by Synapsed Builder

.PHONY: build run test clean docker-build docker-run

# Build the application
build:
	cargo build --release

# Run the application
run:
	cargo run --release

# Run tests
test:
	cargo test --all-features

# Clean build artifacts
clean:
	cargo clean
	rm -rf target/

# Build Docker image
docker-build:
	docker build -t {}:latest .

# Run with Docker
docker-run:
	docker run -it --rm \
		-p 8080:8080 \
		-v $(PWD)/data:/app/data \
		{}:latest

# Development mode with hot reload
dev:
	cargo watch -x run

# Format code
fmt:
	cargo fmt --all

# Lint code
lint:
	cargo clippy --all-targets --all-features -- -D warnings

# Generate documentation
docs:
	cargo doc --all-features --open
"#, self.name, self.name, self.name)
    }
    
    fn generate_readme(&self) -> String {
        format!(r#"# {}

{}

## Overview

This application was generated by Synapsed Builder and includes the following components:

## Components

{}

## Configuration

Configuration is managed through:
- Environment variables (see `.env`)
- Component configuration (see `config.json`)

## Running

### Local Development
```bash
make dev
```

### Production
```bash
make build
make run
```

### Docker
```bash
make docker-build
make docker-run
```

## Testing

```bash
make test
```

## Documentation

```bash
make docs
```

---
Generated by Synapsed Builder
"#, 
            self.name,
            self.description,
            self.components.iter()
                .map(|c| format!("- {}", c))
                .collect::<Vec<_>>()
                .join("\n")
        )
    }
    
    fn generate_github_workflow(&self) -> String {
        format!(r#"name: CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  CARGO_TERM_COLOR: always

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    
    - name: Install Rust
      uses: actions-rs/toolchain@v1
      with:
        toolchain: stable
        override: true
        components: rustfmt, clippy
    
    - name: Cache cargo
      uses: actions/cache@v3
      with:
        path: |
          ~/.cargo/registry
          ~/.cargo/git
          target
        key: ${{{{ runner.os }}}}-cargo-${{{{ hashFiles('**/Cargo.lock') }}}}
    
    - name: Check formatting
      run: cargo fmt -- --check
    
    - name: Run clippy
      run: cargo clippy --all-targets --all-features -- -D warnings
    
    - name: Run tests
      run: cargo test --all-features
    
    - name: Build release
      run: cargo build --release

  docker:
    runs-on: ubuntu-latest
    needs: test
    if: github.ref == 'refs/heads/main'
    steps:
    - uses: actions/checkout@v3
    
    - name: Build Docker image
      run: docker build -t {}:latest .
"#, self.name)
    }
}